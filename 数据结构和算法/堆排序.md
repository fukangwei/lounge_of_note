---
title: 堆排序
categories: 数据结构和算法
mathjax: true
date: 2019-10-03 21:33:28
---
&emsp;&emsp;堆排序(`Heapsort`)是指利用堆积树(`堆`)这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为`大根堆`和`小根堆`，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即`A[PARENT[i]] >= A[i]`。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。<!--more-->

### 堆的定义

&emsp;&emsp;`n`个关键字序列$k_1$、$k_2$、$\cdots$、$k_n$称为`Heap`，当且仅当该序列满足如下性质(简称为`堆性质`)：$k_i <= k_{2i}$且$k_i <= k_{2i + 1}$($1 ≤ i ≤ n/2$)。当然，这是小根堆，大根堆则换成`>=`号。$k_i$相当于二叉树的非叶子结点，$k_{2i}$则是左子节点，$k_{2i + 1}$是右子节点。若将此序列所存储的向量`R[1..n]`看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于(或不小于)其左右孩子(若存在)结点的关键字。
&emsp;&emsp;例如，关键字序列`(10, 15, 56, 25, 30, 70)`和`(70, 56, 30, 25, 15, 10)`分别满足堆性质，故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例。
&emsp;&emsp;小根堆示例的逻辑结构如下：

<div align="center">

``` mermaid
graph TD
    A1[10]; B1[15]
    B2[56]; C1[25]
    C2[30]; C3[70]
    A1-->B1-->C1
    B1-->C2
    A1-->B2-->C3
```

</div>

&emsp;&emsp;小根堆示例的存储结构如下：

<table>
<tr align="center">
    <td>10</td><td>15</td><td>56</td><td>25</td><td>30</td><td>70</td>
</tr>
</table>

&emsp;&emsp;大根堆示例的逻辑结构如下：

<div align="center">

``` mermaid
graph TD
    A1[70]; B1[56]
    B2[30]; C1[25]
    C2[15]; C3[10]
    A1-->B1-->C1
    B1-->C2
    A1-->B2-->C3
```

</div>

&emsp;&emsp;大根堆示例的存储结构如下：

<table>
<tr align="center">
    <td>70</td><td>56</td><td>30</td><td>25</td><td>15</td><td>10</td>
</tr>
</table>

&emsp;&emsp;大根堆和小根堆：根结点(亦称为`堆顶`)的关键字是堆里所有结点关键字中最小者的堆称为`小根堆`，又称`最小堆`。根结点的关键字是堆里所有结点关键字中最大者，称为`大根堆`，又称`最大堆`。注意，堆中任一子树亦是堆；以上讨论的堆实际上是二叉堆(`Binary Heap`)，类似地可定义`k`叉堆。

### 简介

&emsp;&emsp;堆排序利用了大根堆(或小根堆)堆顶记录的关键字最大(或最小)这一特征，使得在当前无序区中选取最大(或最小)关键字的记录变得简单。
&emsp;&emsp;(1) 用大根堆排序的基本思想：

1. 先将初始文件`R[1..n]`建成一个大根堆，此堆为初始的无序区。
2. 再将关键字最大的记录`R[1]`(即堆顶)和无序区的最后一个记录`R[n]`交换，由此得到新的无序区`R[1..n-1]`和有序区`R[n]`，且满足`R[1..n-1].keys ≤ R[n].key`。
3. 由于交换后新的根`R[1]`可能违反堆性质，故应将当前无序区`R[1..n-1]`调整为堆。然后再次将`R[1..n-1]`中关键字最大的记录`R[1]`和该区间的最后一个记录`R[n-1]`交换，由此得到新的无序区`R[1..n-2]`和有序区`R[n-1..n]`，且仍满足关系`R[1..n-2].keys ≤ R[n-1..n].keys`，同样要将`R[1..n-2]`调整为堆。重复这个过程，直到无序区只有一个元素为止。

&emsp;&emsp;(2) 大根堆排序算法的基本操作：

- 建堆：建堆是不断调整堆的过程，从`len/2`处开始调整，一直到第一个节点，此处`len`是堆中元素的个数。建堆的过程是线性的过程，从`len/2`到`0`处一直调用调整堆的过程，相当于$O(h_1) + O(h_2) + \cdots + O(h_{len/2})$，其中`h`表示节点的深度，`len/2`表示节点的个数，这是一个求和的过程，结果是线性的`O(n)`。
- 调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点`i`和它的孩子节点`left(i)`、`right(i)`，选出三者最大(或者最小)者，如果最大(小)值不是节点`i`而是它的一个孩子节点，那边交互节点`i`和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是`lgn`的操作，因为是沿着深度方向进行调整的。
- 堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面`len - 1`个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是`O(nlgn)`。因为建堆的时间复杂度是`O(n)`(调用一次)；调整堆的时间复杂度是`lgn`，调用了`n - 1`次，所以堆排序的时间复杂度是`O(nlgn)`。

### 注意

- 只需做`n - 1`趟排序，选出较大的`n - 1`个关键字即可以使得文件递增有序。
- 用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止。

### 算法分析

&emsp;&emsp;堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用`Heapify`实现的。平均性能为`O(N*logN)`，其他性能有：由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件；堆排序是就地排序，辅助空间为`O(1)`；它是不稳定的排序方法(排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前和排序后他们的相对位置不发生变化)。

``` cpp
#include <stdio.h>
#include <stdlib.h>

/* 自底向上构建最大堆，然后每次保存最大堆的根节点，即可完成堆排序 */
int array[11] = {0, 1, 3, 2, 5, 4, 7, 6, 8, 10, 9};

/* 在《算法导论》中，A[1..A.length]可能有数据，但A[1..A.heap-size]存储的是堆的有效数据 */
int heapnum = 10;

void MAX ( int i ) {
    int left = 2 * i;
    int right = 2 * i + 1;
    int largest = i;
    int mid;

    if ( ( left <= heapnum ) && ( array[left] > array[i] ) ) {
        largest = left;
    }

    if ( ( right <= heapnum ) && ( array[right] > array[largest] ) ) {
        largest = right;
    }

    if ( largest != i ) {
        mid = array[i];
        array[i] = array[largest];
        array[largest] = mid;
        MAX ( largest );
    }
}

/* 如果有n个元素构建堆时，有“n/2”上限个叶节点；依这些叶节点为
   基础建立整个数组的最大堆，因此i的取值范围是“n/2”下限到1 */
void BUILD ( void ) {
    int i = heapnum / 2;

    for ( i = heapnum / 2; i >= 1; i-- ) {
        MAX ( i );
    }
}

/* 最大堆堆顶的元素是数组中最大的元素，每次排序时将堆顶元素与最后一个元素交换，
   然后将最大堆中元素数目减1，然后将新形成的堆重新构建成最大堆。
   这样，每次循环后，堆的第一个数都是数组中最大的数据，然后把其放在
   数组的最后一位。依次循环即可形成升序排列数组 */
void SORT ( void ) {
    int i;
    int mid;

    for ( i = 10; i >= 2; i-- ) {
        mid = array[1];
        array[1] = array[i];
        array[i] = mid;
        heapnum--;
        MAX ( 1 );
    }
}

void OUT ( void ) {
    int i = 1;

    for ( i = 1; i <= 10; i++ ) {
        printf ( "%d\n", array[i] );
    }
}

int main ( void ) {
    BUILD();
    SORT();
    OUT();
    return 0;
}
```