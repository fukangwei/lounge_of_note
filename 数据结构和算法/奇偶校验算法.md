---
title: 奇偶校验算法
categories: 数据结构和算法
date: 2019-02-09 11:19:54
---
&emsp;&emsp;信息是以比特流的方式传输的，类似`01000001`。在传输过程中，有可能会发生错误，比如我们存储了`01000001`，但是取出来却是`01000000`，即低位由`0`变成了`1`。为了检测到这种错误，我们可以通过奇偶校验来实现。假如我们存储的数据是一个字节，那就可以计算每个字节比特位是`1`的个数。如果是偶数个`1`，那么就把第九个位设为`1`；如果是奇数个`1`，那么就把第九个位设为`0`，这样连续`9`个字节比特位为`1`的位数肯定是奇数。这种方法叫做`奇校验`，`偶校验`和此类似。当然，在实际应用中，也可以把一个字节的前`7`位作为数据位，最后一个为作为校验位。<!--more-->
&emsp;&emsp;1. 奇偶校验的常规方法：

``` cpp
unsigned int v; /* 待检测的数字 */
bool parity = false; /* 初始判断标记 */

while ( v ) {
    parity = !parity;
    v = v & ( v - 1 );
}
```

通过`while`循环，每执行一次，`v`中`1`的数目就会减少`1`，如果`v`中`1`的数目为奇数，则`parity = true`，否则`parity = false`。
&emsp;&emsp;2. 通过构建字典表进行奇偶校验：

``` cpp
static const bool ParityTable256[256] = {
    #define P2(n) n, n^1, n^1, n
    #define P4(n) P2(n), P2(n^1), P2(n^1), P2(n)
    #define P6(n) P4(n), P4(n^1), P4(n^1), P4(n)
    P6 ( 0 ), P6 ( 1 ), P6 ( 1 ), P6 ( 0 )
};
```

通过嵌套宏定义，制作一张包括`0`至`255`各个数字中包含`1`的个数，其中包含偶数个`1`，则`ParityTable256[i] = 0`，否则`ParityTable256[i] = 1`。如果要判定`char`类型的`b`中`i`的个数的奇偶，可以直接使用下面的代码：

``` cpp
unsigned char b;
bool parity = ParityTable256[b];
```

而对于`32bit`的数，则使用下面的代码：

``` cpp
unsigned int v;
v ^= v >> 16;
v ^= v >> 8;
bool parity = ParityTable256[v & 0xff];
```

&emsp;&emsp;原理如下：
&emsp;&emsp;(1) 通过`v ^= v >> 16`，将`v`中的低`16`位与高`16`位进行`按位或`(`^`)操作，相当于`0`至`16`位保留`1`的总个数的奇偶与`v`中的`1`的总个数的奇偶相同。
&emsp;&emsp;(2) 通过`v ^= v >> 8`，将`v`中的`9`至`16`位与`0`至`8`位进行`按位或`(`^`)操作，相当于`0`至`8`位保留`1`的总个数的奇偶与`0`至`16`中`1`的总个数的奇偶相同。
&emsp;&emsp;(3) 通过`(1)`和`(2)`操作，最初`v`中`1`的总个数的奇偶与最后`v`中`1`至`8`位中`1`的总个数的奇偶相同，`v & 0xff`相当于获取`v`中`1`至`8`比特位的`1`，然后再查表即可。
&emsp;&emsp;或者使用如下的代码：

``` cpp
unsigned char *p = ( unsigned char * ) &v;
parity = ParityTable256[p[0] ^ p[1] ^ p[2] ^ p[3]];
```

原理为：取`v`的地址，并进行强制类型转换为`char *`。假设`v = 1234`，二进制表示为`00000000_00000000_00000100_11010010`，则`p[0]`为`11010010`，`p[1]`为`00000100`，`p[2]`为`00000000`，`p[3]`为`00000000`，`p[0]^p[1]^p[2]^p[3] = 11010110`。通过`p[0]^p[1]^p[2]^p[3]`操作，将`p[i]`中的所有的`1`都放在一个`8`位的数中，然后查表即可。