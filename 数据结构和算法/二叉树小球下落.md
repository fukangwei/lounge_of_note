---
title: 二叉树小球下落
categories: 数据结构和算法
mathjax: true
date: 2019-10-03 17:00:31
---
&emsp;&emsp;有一棵二叉树，其最大深度为`D`，且所有的叶子深度都相同。所有结点从上到下从左到右编号为$1、2、3、\cdots、2^D-1$。在结点`1`处放一个小球，它会往下落。每个结点上都有一个开关，初始全部关闭，当每次有小球落到一个开关上时，它的状态都会改变。当小球到达一个内结点时，如果该结点的开关关闭，则往上走；否则往下走，直到走到叶子结点：<!--more-->

<div align="center">

``` mermaid
graph TD
    1 --> 2
    1 --> 3
    2 --> 4
    2 --> 5
    3 --> 6
    3 --> 7
    4 --> 8
    4 --> 9
    5 --> 10
    5 --> 11
    6 --> 12
    6 --> 13
    7 --> 14
    7 --> 15
```

</div>

其中，节点`1`的深度为`1`，节点`2`和`3`的深度为`2`。
&emsp;&emsp;一些小球从结点`1`处依次开始下落，最后一个小球将会落到哪里呢？输入叶子深度`D`和小球个数`I`，输出第`I`个小球最后所在的叶子编号。假设`I`不超过整棵树的叶子数，并且$D <= 20$，输出最多包含`1000`组数据。
&emsp;&emsp;样例输入：

``` cpp
4 2
3 4
10 1
2 2
8 128
16 12345
```

样例输出：

``` cpp
12
7
512
3
255
36358
```

&emsp;&emsp;代码一如下：

``` cpp
#include <stdio.h>
#include <string.h>

#define MAXN 20

int s[1 << MAXN]; /* 将1左移20位，即得最大结点个数为“2^MAXN - 1” */

int main ( void ) {
    int D, I;

    while ( scanf ( "%d%d", &D, &I ) == 2 ) {
        memset ( s, 0, sizeof ( s ) ); /* 开关(默认0为关闭状态) */
        int k, n = ( 1 << D ) - 1; /* n是最大结点编号 */

        for ( int i = 0; i < I; i++ ) { /* 连续让I个小球下落 */
            k = 1;

            for ( ;; ) {
                s[k] = !s[k];
                k = s[k] ? k * 2 : k * 2 + 1; /* 根据开关状态选择下落方向 */

                if ( k > n ) {
                    break; /* 已经落“出界”了，下落次数为D */
                }
            }
        }

        printf ( "%d\n", k / 2 ); /* “出界”之前的叶子编号 */
    }

    return 0;
}
```

&emsp;&emsp;对于一个结点`k`，它的左儿子和右儿子的编号分别是$2k$和$2k + 1$。尽管每次小球都是严格下落`D - 1`次，但上述代码中采用`if(k > n) break;`的方法判断`出界`更具一般性。但是该程序运算量太大，由于`I`可以高达$2^{D-1}$，每个测试数据下落总层数可能会高达$2^{19} \ast 19 = 9961472$(即`I * 19`)，而一共可能有`1000`组数据。
&emsp;&emsp;代码二如下：

``` cpp
#include <stdio.h>
#include <string.h>

#define MAXN 20

int s[1 << MAXN]; /* 将1左移20位，即得最大结点个数为“2^MAXN - 1” */

int main ( void ) {
    int D, I; /* 定义小球的个数，即最后一个小球编号为I */

    /* 直接模拟最后一个小球的路线 */
    while ( scanf ( "%d%d", &D, &I ) == 2 ) {
        memset ( s, 0, sizeof ( s ) ); /* 开关(默认0为关闭状态) */
        int k;

        for ( int i = 0; i < I; i++ ) { /* 连续让n个小球下落 */
            k = 1;

            for ( int i = 0; i < D - 1; i++ ) /* 连续进行D-1次下落 */
                if ( I % 2 ) {
                    k = k * 2; /* 当I为奇数时，它是往左走的第“(I+1)/2”个小球 */
                    I = ( I + 1 ) / 2;
                } else {
                    k = k * 2 + 1; /* 当I为偶数时，它是往右走的第“I/2”个小球 */
                    I /= 2;
                }
        }

        printf ( "%d\n", k ); /* 输出最后一个小球I的叶子编号 */
    }

    return 0;
}
```

&emsp;&emsp;由于每个小球都会落在根节点上，前两个小球必然是一个在左子树，一个在右子树。一般情况下，只需看小球编号的奇偶性，就能知道它是最终在哪棵子树中。对于那些落入根节点左子树的小球，只需知道该小球是第几个落在根的左子树里，就可以知道它下一步往左还是往右。依此类推，直到小球落在叶子上。