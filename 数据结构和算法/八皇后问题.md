---
title: 八皇后问题
categories: 数据结构和算法
date: 2019-02-09 00:58:45
---
&emsp;&emsp;在国际象棋棋盘上(`8 * 8`)放置八个皇后，使得任意两个皇后之间不能在同一行、同一列，也不能位于同一条对角线上。问共有多少种不同的方法，并且指出各种不同的放法。<!--more-->
&emsp;&emsp;首先分析一下问题的解，我们每取出一个皇后，放入一行，共有八种不同的放法，然后再放第二个皇后，同样如果不考虑规则，还是有八种放法。于是可以用一个八叉树来描述这个过程，从根节点开始，树每增加一层，便多放一个皇后，直到第`8`层(根节点为`0`层)，最后得到一个完全八叉树。紧接着用深度优先遍历这个八叉树，在遍历的过程中，进行相应的条件的判断，以便去掉不合规则的子树。
&emsp;&emsp;那么具体用什么条件来进行子树的裁剪呢？我们先对问题解的结构做一个约定：用`X[i]`来表示，在第`i`行皇后放在了`X[i]`这个位置。考虑第一个条件，不能在同一行、同一列，于是得到`x[i]`不能相同。剩下一个条件是不能位于对角线上，这个条件不是很明显，经过分析得到，设两个不同的皇后分别在`j`、`k`行上，`x[j]`、`x[k]`分别表示在`j`、`k`行的那一列上，那么不在同一对角线的条件可以写为`abs((j - k)) != abs(x[j] - x[k])`，其中`abs`为求绝对值的函数。
&emsp;&emsp;首先定义一个访问某节点所有子节点的函数：

``` cpp
void backtrack ( int t ) {
    if ( t > num ) { /* num为皇后的数目 */
        sum++; /* sum为所有的可行的解 */

        for ( int m = 1; m < num; m++ ) {
            cout << x[m]; /* 这一行用输出当递归到叶节点的时候，一个可行解 */
        }

        cout << endl;
    } else
        for ( int i = 1; i <= num; i++ ) {
            x[t] = i;

            if ( place ( t ) ) {
                /* 此处的place函数用来进行上面所说的条件判断，如果成立，进入下一级递归 */
                backtrack ( t + 1 );
            }
        }
}
```

&emsp;&emsp;下面定义了条件判断函数：

``` cpp
bool place ( int k ) {
    for ( int j = 1; j < k; j++ )
        if ( abs ( x[k] - x[j] ) == abs ( k - j ) || x[j] == x[k] ) {
            return false;
        }

    return true;
}
```

&emsp;&emsp;最后就是主程序的调用了：

``` cpp
static int num = 0;
static int *x = NULL;
static int sum = 0;

int main() {
    num = 8;
    sum = 0;
    x = new int[num + 1];

    for ( int i = 0; i <= num; i++ ) {
        x[i] = 0;
    }

    backtrack ( 1 );
    cout << "方案共有" << sum;
}
```